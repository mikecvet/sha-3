
/*
 * From https://keccak.team/keccak_specs_summary.html
 * 
 * Rotation offsets for the rho function; based on triangular numbers.
 */
const ROTATION_OFFSETS: [[u32; 5]; 5] = [
    [0,  1,  62, 28, 27],
    [36, 44, 6,  55, 20],
    [3,  10, 43, 25, 39],
    [41, 45, 15, 21, 8],
    [18, 2,  61, 56, 14]
  ];

  /*
   * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.5 and Algorithm 5
   * 
   * The iota mapping is parameterized by the round index, i_r, whose values are specified in 
   * Step 2 of Algorithm 7 for computing KECCAK-p[b, nr], in Sec. 3.3. 
   * Within the specification of ι in Algorithm 6 below, this parameter determines l + 1 bits 
   * of a lane value called the round constant, denoted by RC. Each of these l + 1 bits is 
   * generated by a function that is based on a linear feedback shift register.
   * 
   * Defines constant values XOR'd into first word of the hash state within the iota function.
   */
const ROUND_CONSTANTS: [u64; 24] = [
    0x0000000000000001, 0x0000000000008082, 0x800000000000808A,
    0x8000000080008000, 0x000000000000808B, 0x0000000080000001,
    0x8000000080008081, 0x8000000000008009, 0x000000000000008A,
    0x0000000000000088, 0x0000000080008009, 0x000000008000000A,
    0x000000008000808B, 0x800000000000008B, 0x8000000000008089,
    0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
    0x000000000000800A, 0x800000008000000A, 0x8000000080008081,
    0x8000000000008080, 0x0000000080000001, 0x8000000080008008
  ];

struct State {
    /* 
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.1
     * 
     * This two-dimensional array represents the 1600 bits of three-dimensional state described 
     * in the specification. 
     */
    state: [[u64; 5]; 5]
}

impl State {
    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 4 and Algorithm 8
     * 
     * For i from 0 to n - 1, let S = f(S ⊕ (Pi || 0c))
     * 
     * This function XORs the input word into the appropriate state block, as identified
     * by the index value.
     */
    fn absorb (&mut self, indx: usize, word: u64) {
        self.state[indx / 5][indx % 5] ^= word;
    }

    fn squeeze (&mut self, rate: usize, len: usize) -> Vec<u8> {
        let mut bytes = Vec::new();
        let x = rate / 64;
        let len_bytes = len / 8;

        while bytes.len() < len_bytes {
            for i in 0..x {
                bytes.extend_from_slice(&self.state[i / 5][i % 5].to_le_bytes());
            }

            self.permute();
        }

        return bytes[0..len_bytes].to_vec();
    }

    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.3
     * 
     * Given a state array A and a round index ir, the round function Rnd is the transformation that results 
     * from applying the step mappings θ, ρ, π, χ, and ι, in that order, i.e.,: 
     *   Rnd(A, ir) = ι(χ(π(ρ(θ(A)))), ir).
     * 
     * See also https://keccak.team/keccak_specs_summary.html for pseudo-code descriptions of 
     * this permutation and the underlying functions.
     */
    fn permute(&mut self) {
        for i in 0..24 {
            self.theta();
            self.rho_and_pi();
            self.chi();
            self.iota(i);
        }
    }

    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.1
     * 
     * The effect of θ is to XOR each bit in the state with the parities of two columns in the array. 
     * In particular, for the bit A[x0, y0, z0], the x-coordinate of one of the columns is (x_0 - 1) mod 5, 
     * with the same z-coordinate, z0, while the x-coordinate of the other column is (x_0 + 1) mod 5, 
     * with z-coordinate (z_0 - 1) mod w.
     */
    fn theta (&mut self) {
        let mut c: [u64; 5] = [0; 5];
        let mut d: [u64; 5] = [0; 5];
    
        for i in 0..5 {
            // Calulate parities for each column
            c[i] = self.state[0][i] ^ self.state[1][i] ^ self.state[2][i] ^ self.state[3][i] ^ self.state[4][i];
        }
    
        for row in 0..5 {
            // Calculate XOR of column to the left and right
            // would use -1 but can't subtract here
            d[row] = c[(row + 4) % 5] ^ c[(row + 1) % 5].rotate_left(1);
    
            for col in 0..5 {
                // XOR state with corresponding elements from D array
                self.state[col][row] ^= d[row];
            }
        }
    }
    
    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.2 and 3.2.3
     * 
     * The effect of ρ is to rotate the bits of each lane by a length, called the offset, which depends on 
     * the fixed x and y coordinates of the lane. Equivalently, for each bit in the lane, the z coordinate 
     * is modified by adding the offset, modulo the lane size.
     * 
     * The effect of π is to rearrange the positions of the lanes.
     * 
     * The rho and pi functions tend to be combined in most implementations for performance reasons. 
     * This is also the case in the psuedocode provided by the Keccak team in 
     * https://keccak.team/keccak_specs_summary.html
     */
    fn rho_and_pi (&mut self) {
        let mut b: [[u64; 5]; 5] = [[0; 5]; 5];
    
        for x in 0..5 {
            for y in 0..5 {
                let y2 = (3 * y + 2 * x) % 5;
                b[y2][y] = self.state[y][x].rotate_left(ROTATION_OFFSETS[y][x]);
            }
        }
    
        for x in 0..5 {
            for y in 0..5 {
                self.state[x][y] = b[x][y];
            }
        }
    }
    
    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.4
     * 
     * The effect of χ is to XOR each bit with a non-linear function of two other bits in its row.
     * 
     * The chi function is unique in this hash algorithm as it is the only nonlinear function 
     * of the five which compose the Keccak permutation function.
     */
    fn chi (&mut self) {
        for row in 0..5 {
            let mut temp: [u64; 5] = [0; 5];
            for col in 0..5 {
                temp[col] = self.state[row][col];
            }
    
            for col in 0..5 {
                self.state[row][col] ^= (!temp[(col + 1) % 5]) & temp[(col + 2) % 5];
            }
        }
    }
    
    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.5
     * 
     * The effect of ι is to modify some of the bits of Lane (0, 0) in a manner that depends on the 
     * round index ir. The other 24 lanes are not affected by ι.
     * 
     * The iota function is the only function of the Keccak function set which introduces external constants
     * into the state; the others work solely on the existing state. 
     */
    fn iota (&mut self, round: usize) {
        self.state[0][0] ^= ROUND_CONSTANTS[round];
    }
}

impl Default for State {
    fn default () -> State {
        State {
            state: [[0; 5]; 5],
        }
    }
}

/**
 * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 5.1 and B.2
 * 
 * For the SHA-3 functions, either a two- or four-bit suffix is appended to the message M to produce the 
 * input string N to KECCAK[c], and additional bits are appended as part of the multi- rate padding rule.
 * For most applications, the message is byte-aligned, i.e., len(M) = 8m for a nonnegative integer m. 
 * In this case, the total number of bytes, denoted by q, that are appended to the message is 
 * determined as follows by m and the rate r: q = (r/8) – (m mod (r/8)).
 * 
 * This function pads the input message according to the specification:
 *   - Appends byte 0x06
 *     - If the message length is now congruent to the rate, ORs the last byte with x80
 *   - Append 0x0 until 1 byte until length is 1 less than a multiple of rate
 *   - Append 0x80
 */
fn 
pad (message: &mut Vec<u8>, rate: usize) {

    let rate_bytes = rate / 8;
    if message.len() == rate_bytes -1 {
        // Special case. 0x06 and 0x80 must always be present. If the message length is 1 byte less than a 
        // multiple of the rate, append these two values OR'd together.
        message.push(0x06 | 0x80);
    } else {
        message.push(0x06);
        while (message.len() % rate_bytes) != rate_bytes - 1 {
            message.push(0x0);
        }
        message.push(0x80);
    }
}

pub fn
hash (message: &mut Vec<u8>, size: usize) -> String {

    let mut state = State::default();

    let rate = match size {
        224 => 1152,
        256 => 1088,
        384 => 832,
        512 => 576,
        _ => 1088
    };

    pad (message, rate);

    for block in message.chunks(rate / 8) {

        let mut indx = 0;
        for chunk in block.chunks(8) {
            // Convert message byte chunks into a little-endian u64 integer
            let (b1, b2, b3, b4, b5, b6, b7, b8) 
              = (chunk[0] as u64, chunk[1] as u64, chunk[2] as u64, chunk[3] as u64, 
                  chunk[4] as u64, chunk[5] as u64, chunk[6] as u64, chunk[7] as u64);

             let word = (b8 << 56) | (b7 << 48) | (b6 << 40) | (b5 << 32) | (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;

            state.absorb(indx, word);

            indx += 1;
        }

        state.permute();
    }

    // Encode state into base 64
    return hex::encode(
        &state.squeeze(rate, size)
    ); 
}

/**
 * Convenience function for passing strings; converts given string to a Vector of u8 bytes for 
 * the hash() function.
 */
pub fn 
hash_string (message: &str, n: usize) -> String {
    let mut message_bytes = message.as_bytes().to_vec();
    return hash (&mut message_bytes, n);
}