/*
 * From https://keccak.team/keccak_specs_summary.html
 * 
 * Rotation offsets for the rho function; based on triangular numbers.
 */
const ROTATION_OFFSETS: [[u32; 5]; 5] = [
    [0,  1,  62, 28, 27],
    [36, 44, 6,  55, 20],
    [3,  10, 43, 25, 39],
    [41, 45, 15, 21, 8],
    [18, 2,  61, 56, 14]
  ];

  /*
   * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.5 and Algorithm 5
   * 
   * The iota mapping is parameterized by the round index, i_r, whose values are specified in 
   * Step 2 of Algorithm 7 for computing KECCAK-p[b, nr], in Sec. 3.3. 
   * Within the specification of iota in Algorithm 6 below, this parameter determines l + 1 bits 
   * of a lane value called the round constant, denoted by RC. Each of these l + 1 bits is 
   * generated by a function that is based on a linear feedback shift register.
   * 
   * Defines constant values XOR'd into first word of the hash state within the iota function.
   * These can be found on the Keccak team website: https://keccak.team/keccak_specs_summary.html 
   * under "round constants"
   */
const ROUND_CONSTANTS: [u64; 24] = [
    0x0000000000000001, 0x0000000000008082, 0x800000000000808A,
    0x8000000080008000, 0x000000000000808B, 0x0000000080000001,
    0x8000000080008081, 0x8000000000008009, 0x000000000000008A,
    0x0000000000000088, 0x0000000080008009, 0x000000008000000A,
    0x000000008000808B, 0x800000000000008B, 0x8000000000008089,
    0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
    0x000000000000800A, 0x800000008000000A, 0x8000000080008081,
    0x8000000000008080, 0x0000000080000001, 0x8000000080008008
  ];

struct State {
    /* 
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.1
     * 
     * This two-dimensional array represents the 1600 bits of three-dimensional state described 
     * in the specification.
     */
    state: [[u64; 5]; 5]
}

impl State {
    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 4 and Algorithm 8, step 6
     * 
     * For i from 0 to n - 1, let S = f(S ⊕ (Pi || 0c))
     * 
     * This function XORs the input word into the appropriate state block, as identified
     * by the index value.
     */
    fn absorb (&mut self, indx: usize, word: u64) {
        // Some transformation from single index to element in this 2D state array
        self.state[indx / 5][indx % 5] ^= word;
    }

    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 4 and Algorithm 8, steps 7 to 10
     * 
     * This function extracts bytes from the state array and returns a vector capturing the
     * number of digest bytes corresponding to the request digest output size.
     */
    fn squeeze (&mut self, rate: usize, md_size: usize) -> Vec<u8> {
        let mut bytes = Vec::new();
        let num_words = rate / 64;
        let len_bytes = md_size / 8;

        // Iterates until sufficient bytes have been read to fill the final message digest byte vector
        while bytes.len() < len_bytes {
            // Read the first 'num_words` integers from the state array
            for i in 0..num_words {
                bytes.extend_from_slice(&self.state[i / 5][i % 5].to_le_bytes());
            }

            if bytes.len() < len_bytes {
                // If we have more bytes to read, permute the state for the next round of reading
                self.permute();
            }
        }

        // Return the first len_bytes of the result, consistent with requested message digest size
        return bytes[0..len_bytes].to_vec();
    }

    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.3
     * 
     * Given a state array A and a round index ir, the round function Rnd is the transformation that results 
     * from applying the step mappings θ, ρ, π, χ, and ι, in that order, i.e.: 
     *   Rnd(A, ir) = ι(χ(π(ρ(θ(A)))), ir).
     * 
     * See also https://keccak.team/keccak_specs_summary.html for pseudo-code descriptions of 
     * this permutation, its 24 rounds, and the underlying functions.
     */
    fn permute (&mut self) {
        for i in 0..24 {
            self.theta();
            self.rho_and_pi();
            self.chi();
            self.iota(i);
        }
    }

    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.1
     * 
     * The effect of theta is to XOR each bit in the state with the parities of two columns in the array. 
     * In particular, for the bit A[x0, y0, z0], the x-coordinate of one of the columns is (x_0 - 1) mod 5, 
     * with the same z-coordinate, z_0, while the x-coordinate of the other column is (x_0 + 1) mod 5, 
     * with z-coordinate (z_0 - 1) mod w.
     */
    fn theta (&mut self) {
        let mut c: [u64; 5] = [0; 5];
    
        for i in 0..5 {
            // Calulate parities for each column; c[i] contains row value XORs for each column i
            c[i] = self.state[0][i] ^ self.state[1][i] ^ self.state[2][i] ^ self.state[3][i] ^ self.state[4][i];
        }
    
        for col in 0..5 {
            // Calculate XOR of column to the left and right
            // would use -1 as in the specification, but can't subtract from usize here
            let t = c[(col + 4) % 5] ^ c[(col + 1) % 5].rotate_left(1);
    
            for row in 0..5 {
                // XOR state column with corresponding elements from D array
                self.state[row][col] ^= t;
            }
        }
    }
    
    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.2 and 3.2.3
     * 
     * The effect of rho is to rotate the bits of each lane by a length, called the offset, which depends on 
     * the fixed x and y coordinates of the lane. Equivalently, for each bit in the lane, the z coordinate 
     * is modified by adding the offset, modulo the lane size.
     * 
     * The effect of pi is to rearrange the positions of the lanes.
     * 
     * The rho and pi functions tend to be combined in most implementations for performance reasons. 
     * This is also the case in the psuedocode provided by the Keccak team in 
     * https://keccak.team/keccak_specs_summary.html
     */
    fn rho_and_pi (&mut self) {
        let mut b: [[u64; 5]; 5] = [[0; 5]; 5];
    
        // Collect the rotated integers
        for x in 0..5 {
            for y in 0..5 {
                let y2 = (3 * y + 2 * x) % 5;
                b[y2][y] = self.state[y][x].rotate_left(ROTATION_OFFSETS[y][x]);
            }
        }
    
        // Copy them back into the state
        for x in 0..5 {
            for y in 0..5 {
                self.state[x][y] = b[x][y];
            }
        }
    }
    
    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.4
     * 
     * The effect of chi is to XOR each bit with a non-linear function of two other bits in its row.
     * 
     * The chi function is unique in this hash algorithm as it is the /only/ nonlinear function 
     * of the five which compose the Keccak permutation function.
     */
    fn chi (&mut self) {
        for row in 0..5 {
            let mut temp: [u64; 5] = [0; 5];
            for col in 0..5 {
                temp[col] = self.state[row][col];
            }
    
            for col in 0..5 {
                self.state[row][col] ^= (!temp[(col + 1) % 5]) & temp[(col + 2) % 5];
            }
        }
    }
    
    /**
     * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 3.2.5
     * 
     * The effect of iota is to modify some of the bits of Lane (0, 0) in a manner that depends on the 
     * round index ir. The other 24 lanes are not affected by iota.
     * 
     * The iota function is the only function of the Keccak function set which introduces external constants
     * into the state; the others work solely on the existing state. It only XORs these external constants into 
     * the first word of the state array; the specific constant changes based on the round number.
     */
    fn iota (&mut self, round: usize) {
        self.state[0][0] ^= ROUND_CONSTANTS[round];
    }
}

/**
 * Default empty State constructor.
 */
impl Default for State {
    fn default () -> State {
        State {
            state: [[0; 5]; 5],
        }
    }
}

/**
 * From https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 5.1 and B.2
 * 
 * For the SHA-3 functions, either a two- or four-bit suffix is appended to the message M to produce the 
 * input string N to KECCAK[c], and additional bits are appended as part of the multi- rate padding rule.
 * For most applications, the message is byte-aligned, i.e., len(M) = 8m for a nonnegative integer m. 
 * In this case, the total number of bytes, denoted by q, that are appended to the message is 
 * determined as follows by m and the rate r: q = (r/8) – (m mod (r/8)).
 * 
 * This function pads the input message according to the specification:
 *   - Appends byte 0x06
 *     - If the message length is now congruent to the rate, ORs the last byte with x80
 *   - Append 0x0 until 1 byte until length is 1 less than a multiple of rate
 *   - Append 0x80
 */
fn 
pad (message: &mut Vec<u8>, rate: usize) {

    let rate_bytes = rate / 8;
    if message.len() == rate_bytes -1 {
        // Special case. 0x06 and 0x80 must always be present. If the message length is 1 byte less than a 
        // multiple of the rate, append these two values OR'd together so the last byte is 0x86
        message.push(0x06 | 0x80);
    } else {
        // Messages are padded to something like [... 0x06, 0x0, 0x0 ..., 0x80]
        message.push(0x06);
        while (message.len() % rate_bytes) != rate_bytes - 1 {
            message.push(0x0);
        }
        message.push(0x80);
    }
}

/**
 * Outer hash function. Primarily organized to orchestrate the /Sponge Construction/ operations as 
 * defined in the corresponding section section from the SHA-3 / FIPS PUB 202 specification 
 *   https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf # 4
 * 
 * This function:
 *  - Pads the input message via pad()
 *  - Breaks the message into 512-bit chunks
 *  - Converts each chunk into a 64-bit word
 *  - Absorbs the word into the "sponge" state
 *  - Extracts the final hashed output via squeeze()
 *  - Converts the resulting byte array to a hex string and returns it
 */
pub fn
hash (message: &mut Vec<u8>, md_size: usize) -> String {

    let mut state = State::default();

    /*
     * Determine the bit rate from the specified algorithm 
     * The "capacity" of each algorithm variant is a proxy for cryptographic strength. It is 
     * defined as double the requested message digest size. The bit rate is then the size of the
     * maximal state bit size (1600) minus the capacity. 
     * 
     * For example, the result of SHA-512 will be a digest of 512 bits; double 512 is 1024, and 
     * 1600 - 1024 = 574, defined as the corresponding bit rate below.
     */ 
    let rate = match md_size {
        224 => 1152,
        256 => 1088,
        384 => 832,
        512 => 576,
        _ => 1088
    };

    // Pad and extend the message vector
    pad (message, rate);

    // Break the message vector into 512-bit chunks; absorb each chunk then permute the state
    for block in message.chunks(rate / 8) {
        let mut indx = 0;

        // Each 512-bit chunk is further broken into 8 64-bit words; each is independently 
        // absorbed into the state array
        for chunk in block.chunks(8) {
            // Convert message byte chunks into a little-endian u64 integer
            let (b1, b2, b3, b4, b5, b6, b7, b8) 
              = (chunk[0] as u64, chunk[1] as u64, chunk[2] as u64, chunk[3] as u64, 
                  chunk[4] as u64, chunk[5] as u64, chunk[6] as u64, chunk[7] as u64);

            let word = (b8 << 56) | (b7 << 48) | (b6 << 40) | (b5 << 32) | (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;

            state.absorb(indx, word);
            indx += 1;
        }

        // After each chunk, run state permutations
        state.permute();
    }

    // Encode state into base 64
    return hex::encode(
        &state.squeeze(rate, md_size)
    ); 
}

/**
 * Convenience function for passing strings; converts given string to a Vector of u8 bytes for 
 * the hash() function.
 */
pub fn 
hash_string (message: &str, n: usize) -> String {
    let mut message_bytes = message.as_bytes().to_vec();
    return hash (&mut message_bytes, n);
}